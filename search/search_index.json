{"docs":[{"location":"/index.html","text":"目录 《Netty实战》勘误 第1章——Netty——异步和事件驱动\n《Netty实战》\nNetty实战是一本写给Java和Scala开发者的Netty书。","title":""},{"location":"/contents.html","text":"","title":"目录 ·"},{"location":"/contents.html#目录","text":"","title":"目录"},{"location":"/errata/index.html","text":"","title":"《Netty实战》勘误 ·"},{"location":"/errata/index.html#netty实战-勘误","text":"","title":"《Netty实战》勘误"},{"location":"/errata/index.html#1-页码-ii-行数-11-印次-1-修订印次-3","text":"COBAL 应该是 COBOL.","title":"1 页码：ii • 行数：11 • 印次 1 •　修订印次： 3"},{"location":"/errata/index.html#2-页码-前言-行数-2-印次-1-修订印次-2","text":"“当我从2001年年末” 中的“2001年”应该是“2011年”","title":"2 页码：前言 • 行数：2 • 印次 1 •　修订印次： 2"},{"location":"/errata/index.html#3-页码-5-行数-1-印次-1-修订印次-2","text":"“44 代码清单1-1 ”中的“44”是排版问题，要去掉","title":"3 页码：5 • 行数：1 • 印次 1 •　修订印次： 2"},{"location":"/errata/index.html#4-页码-12-行数-10-印次-1","text":"如图 1-3 所示的那些： 原文是包含 those的，这里改为 如图 1-3 所示，即省译","title":"4 页码：12 • 行数：10 • 印次 1"},{"location":"/errata/index.html#5-页码-13-行数-8-印次-1-修订印次-2","text":"“你可能有的在你的 ChannelHandler 中需要进行同步的任何顾虑”一句\n这里是按照原文翻译的，将“将你的 ChannelHandler”改为了“ChannelHandler 实现”更有利于读者理解。","title":"5 页码：13 • 行数：8 • 印次 1 •　修订印次： 2"},{"location":"/errata/index.html#6-页码-18-行数-最上面代码第6-7行-印次-1-修订印次-3","text":"将未决消息（添加译者注）冲刷到远程节点，并关闭该Channel。 //译者注 未决消息（pending message）是指目前暂存于ChannelOutboundBuffer中的消息，在下一次调用flush()或者writeAndFlush()方法时将会尝试写出到套接字。","title":"6 页码：18 • 行数：最上面代码第6-7行 • 印次 1 •　修订印次： 3"},{"location":"/errata/index.html#7-页码-19-行数-20-印次-1-修订印次-2","text":"if (args.length != 1) {\n    System.err.println(\"Usage: \" + EchoServer.class.getSimpleName() + \" <port>\");\n}\n应该是：\nif (args.length != 1) {\n    System.err.println(\"Usage: \" + EchoServer.class.getSimpleName() + \" <port>\");\n    return;\n}\n即需要按照下面的代码清单处理，本书英文版也有这个问题，感谢你哈。 其中 return; 属于 if语句，并且需正确对齐","title":"7 页码：19 • 行数：20 • 印次 1 •　修订印次： 2"},{"location":"/errata/index.html#8-页码-33-行数-2-印次-1-修订印次-3","text":"ChannelPipeline提供了 ChannelHandler链的容器\n改为 ChannelPipeline 为 ChannelHandler 链提供了容器\n调整句式，更加方便读者阅读习惯。","title":"8 页码：33 • 行数：2 • 印次 1 •　修订印次： 3"},{"location":"/errata/index.html#9-页码-37-行数-6-印次-1","text":"拆句+补译：\n与 ServerChannel 相关联的 EventLoopGroup 将分配一个负责为传入连接请求创建Channel 的 EventLoop。\n改为：\n与 ServerChannel 相关联的 EventLoopGroup 将分配一个 EventLoop，该EventLoop将负责为传入连接请求创建Channel。","title":"9 页码：37 • 行数：6 • 印次 1"},{"location":"/errata/index.html#10-页码-50-行数-1-印次-1-修订印次-3","text":"在首次出现X和--时，应加译者注说明X和–所代表的意思\n表中X表示支持，–表示不支持。——译者注","title":"10 页码：50 • 行数：1 • 印次 1 •　修订印次： 3"},{"location":"/errata/index.html#11-页码-53-行数-19-印次-1-修订印次-2","text":"此处不能算勘误，算是改进。\n“试图移动 写索引 超过这个值将会触发一个异常”中的写索引 改为 写索引(即writerIndex) 更加有利于读者理解。","title":"11 页码：53 • 行数：19 • 印次 1 •　修订印次： 2"},{"location":"/errata/index.html#12-页码-70-行数-倒数第2行-印次-1","text":"这里系原书中就存在的一个技术错误，或者说表意不明。 The Channel was created, but isn’t registered to an EventLoop 修改为：\nChannel 已经从EventLoop中注销了。\n添加译者注：只要该Channel没有关闭，我们就可以再次将该Channel注册到EventLoop。","title":"12 页码：70 • 行数：倒数第2行 • 印次 1"},{"location":"/errata/index.html#13-页码-78-行数-表6-6-第一行-印次-1-修订印次-3","text":"表6-6第1行左边应该是： addFirst\naddBefore\naddAfter\naddLast\n目前全部挤在一起了，且第一个AddFirst应该是addFirst","title":"13 页码：78 • 行数：表6-6 第一行 • 印次 1 •　修订印次： 3"},{"location":"/errata/index.html#14-页码-78-行数-4-印次-1-修订印次-3","text":"ChannelHandler 可以通过添加、删除……的布局。\n有歧义，修改为：\n通过调用 ChannelPipeline上的相关方法，ChannelHandler可以添加、 删除或者替换其他的ChannelHandler，从而实时地修改 ChannelPipeline的布局。","title":"14 页码：78 • 行数：4 • 印次 1 •　修订印次： 3"},{"location":"/errata/index.html#15-页码-78-行数-7-印次-1-修订印次-3","text":"页码：78 • 行数：7 • 印次 1 •　修订印次： 3\n表 6-6 ChannelHandler的用于修改ChannelPipeline的方法\n系原文有误：\nTable 6.6 ChannelHandler methods for modifying a ChannelPipeline\n应该修改为：\nChannelPipeline上的相关方法，由ChannelHandler用来修改ChannelPipeline 的布局","title":"15 页码：78 • 行数：7 • 印次 1 •　修订印次： 3"},{"location":"/errata/index.html#16-页码-82-行数-7-印次-1-修订印次-3","text":"ChannelHandler Context多了一个空格，应该是ChannelHandlerContext","title":"16 页码：82 • 行数：7 • 印次 1 •　修订印次： 3"},{"location":"/errata/index.html#17-页码-85-行数-2-印次-1-修订印次-2","text":"这里不算勘误，算改进，以帮助读者理解：\n“用于这种用法的 ChannelHandler 必须要使用 @Sharable 注解标注。”\n改进为：\n“对于这种用法（指在多个ChannelPipeline中共享同一个ChannelHandler），对应的ChannelHandler必须要使用 @Sharable 注解标注。”","title":"17 页码：85 • 行数：2 • 印次 1 •　修订印次： 2"},{"location":"/errata/index.html#18-页码-93-行数-27-印次-1-修订印次-2","text":"类型和变量之间缺少空格\n错误：ThreadFactorythreadFactory\n应该是ThreadFactory threadFactory","title":"18 页码：93 • 行数：27 • 印次 1 •　修订印次： 2"},{"location":"/errata/index.html#19-页码-105-行数-25-印次-1-修订印次-2","text":"这里更多的还是考虑到了对仗，但是从技术性描述来说的确不是特别准确。\n首先出现 Accepted Channel 的时候，是在英文原版39页，描述引导的时候，这里，我们可以看到前面一会儿使用了connection has been accepted一会儿又是Channel,所以从很早很早开始，这两个词几乎就在混用了和相互指代了，即在描述性的文字中，二者是一个意思。\n同样在原书49页也有 A new Channel was accepted and is ready，而并不是 A new Connection was accepted and is ready.\n在原书50页： OP_ACCEPT Requests notification when a new connection is accepted, and a Channel is created.\n这里有您的论调的来源：）\n然后我们将目光转到113页，这里文中前面也有出现过accepted Channel,后面出现了accepting(原书为斜体) ServerChannel,即我们不要逐一输入，而要替换为上下文对象。\n其他出现accepting的地方的几处是accepting connections以及accepting new connections。\n所以这里我们更多第可以看做是对仗。\n当然求翻译准确性，我们的确可以修改，我建议改为下面的形式。\n接受(斜体)（子 Channel ）的 ServerChannel。 //添加译者注 //实际上是指接受来自客户端的连接，在连被接接受之后，该ServerChannel将会创建一个对应的子Channel`。","title":"19 页码：105 • 行数：25 • 印次 1 •　修订印次： 2"},{"location":"/errata/index.html#20-页码-110-行数-24-印次-1-修订印次-3","text":"代码清单8-7中的：\nnew AttributeKey(“ID”)\n应该是：\nAttributeKey.newInstance(“ID”)(添加译者注)\n// 需要注意的是，AttributeKey上同时存在newInstance(String)和valueOf(String)方法，它们都可以用来获取具有指定名称的AttributeKey实例，不同的是，前者可能会在多线程环境下使用时抛出异常（实际上调用了createOrThrow(String)方法）——通常适用于初始化静态变量的时候；而后者（实际上调用了getOrCreate(String)方法）则更加通用（线程安全）。——译者注\n（系原书代码清单错误，默认的构造函数是private的，在本书中文版源代码下载链接https://github.com/ReactivePlatform/netty-in-action-cn中是正确的。）","title":"20 页码：110 • 行数：24 • 印次 1 •　修订印次： 3"},{"location":"/errata/index.html#21-页码-115-行数-9-1-印次-1-修订印次-3","text":"图9-2，最后应该是 ABC - DEF - GHI","title":"21 页码：115 • 行数：9-1 • 印次 1 •　修订印次： 3"},{"location":"/errata/index.html#22-页码-131-行数-20-印次-1-修订印次-2","text":"原子类型 改为 原始类型","title":"22 页码：131 • 行数：20 • 印次 1 •　修订印次： 2"},{"location":"/errata/index.html#23-页码-132-行数-图10-4-印次-1-修订印次-3","text":"图中有误：\nChannelInboundHandler 需要改为 ChannelOutboundHandler\n2.需要补充一条箭头线。\nimg","title":"23 页码：132 • 行数：图10-4 • 印次 1 •　修订印次： 3"},{"location":"/errata/index.html#24-页码-147-行数-表11-3-印次-1","text":"不算勘误，译法改进:\n“数据帧：属于上一个 BinaryWebSocketFrame 或者 TextWebSocketFrame的文本的或者二进制数据”\n这里我们改进为，按照：https://github.com/ReactivePlatform/netty-in-action-cn/issues/6\n“数据帧：属于上一个 BinaryWebSocketFrame 或者 TextWebSocketFrame的二进制或者文本数据”","title":"24 页码：147 • 行数：表11-3 • 印次 1"},{"location":"/errata/index.html#25-页码-166-行数-37-印次-1-修订印次-3","text":"text/plain 中的 plain\n应该是\nhtml\n这样显示才正确，代码清单中英文版都已经更新","title":"25 页码：166 • 行数：37 • 印次 1 •　修订印次： 3"},{"location":"/errata/index.html#26-页码-173-行数-24-印次-1-修订印次-3","text":"补充说明：\n第二个客户端则是通过……连接的（添加译者注）。\n// 也可以通过在一个新的浏览器中访问 http://localhost:9999 来达到同样的目的，从而代替 Chrome 浏览器的开发者工具。——译者注","title":"26 页码：173 • 行数：24 • 印次 1 •　修订印次： 3"},{"location":"/errata/index.html#27-页码-174-行数-倒数第2行-印次-5","text":"SSLEng.ine 应该是 SSLEngine","title":"27 页码：174 • 行数：倒数第2行 • 印次 5"},{"location":"/errata/index.html#28-页码-239-行数-24-印次-1","text":"不算勘误，译法改进\n“不被引用了这个项目所产生的构件的其他项目，视为传递依赖。”\n修改为\n“不会被其他项目视为传递依赖，这些项目引用了由这个项目所生成的构件。”","title":"28 页码：239 • 行数：24 • 印次 1"},{"location":"/chapter-01/index.html","text":"","title":"第1章——Netty——异步和事件驱动 ·"},{"location":"/chapter-01/index.html#第1章-netty-异步和事件驱动","text":"","title":"第1章——Netty——异步和事件驱动"},{"location":"/chapter-01/index.html#代码清单-1-1-阻塞-i-o-示例","text":"Java public void serve(int portNumber) throws IOException {\n    //创建一个新的 ServerSocket，用以监听指定端口上的连接请求\n    ServerSocket serverSocket = new ServerSocket(portNumber);\n    //对accept()方法的调用将被阻塞，直到一个连接建立\n    Socket clientSocket = serverSocket.accept();\n    //这些流对象都派生于该套接字的流对象\n    BufferedReader in = new BufferedReader(\n            new InputStreamReader(clientSocket.getInputStream()));\n    PrintWriter out =\n            new PrintWriter(clientSocket.getOutputStream(), true);\n    String request, response;\n    //处理循环开始\n    while ((request = in.readLine()) != null) {\n        if (\"Done\".equals(request)) {\n            break;\n        }\n        //请求被传递给服务器的处理方法\n        response = processRequest(request);\n        //服务器的响应被发送给了客户端\n        out.println(response);\n        //继续执行处理循环\n    }\n} Scala @throws[IOException]\ndef serve(portNumber: Int): Unit = {\n  //创建一个新的 ServerSocket，用以监听指定端口上的连接请求\n  val serverSocket = new ServerSocket(portNumber)\n  //对accept()方法的调用将被阻塞，直到一个连接建立\n  val clientSocket = serverSocket.accept\n  //这些流对象都派生于该套接字的流对象\n  val in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream))\n  val out = new PrintWriter(clientSocket.getOutputStream, true)\n  var request: String = in.readLine\n  var response: String = null\n  //处理循环开始\n  while (request ne null) {\n    if (\"Done\" != request) {\n      //请求被传递给服务器的处理方法\n      response = processRequest(request)\n      //服务器的响应被发送给了客户端\n      out.println(response)\n      //继续执行处理循环\n    }\n    request = in.readLine\n  }","title":"代码清单 1-1 阻塞 I/O 示例"}]}